#Requires -Version 5.1 # Or higher for PowerShell Core if on Linux/macOS

param (
    [Parameter(Mandatory=$true)]
    [string]$TablerRepoPath,

    [Parameter(Mandatory=$false)]
    [string]$OutputNamespace = "BlazorApp.Shared.TablerIcons", # Or your component library's namespace

    [Parameter(Mandatory=$false)]
    [string]$OutputFilePath = "./TablerIconNames.cs" # Relative to script location or absolute
)

function ConvertTo-PascalCaseIdentifier {
    param (
        [string]$Name
    )

    # Handle C# keywords by prefixing with "@"
    # Common keywords, add more if needed
    $csharpKeywords = @(
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
        "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
        "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
        "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
        "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
        "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
        "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw",
        "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using",
        "virtual", "void", "volatile", "while"
    )

    # Remove ".svg" if present (should be handled by BaseName but as a fallback)
    $nameWithoutExtension = $Name.Replace(".svg", "")

    # Split by hyphen or underscore
    $parts = $nameWithoutExtension -split '[-_]'

    $pascalCaseName = ""
    foreach ($part in $parts) {
        if (-not [string]::IsNullOrWhiteSpace($part)) {
            $pascalCaseName += $part.Substring(0, 1).ToUpper() + $part.Substring(1).ToLower()
        }
    }

    # If the original name starts with a number, or the PascalCase result starts with a number
    if ($nameWithoutExtension[0] -match '\d' -or $pascalCaseName[0] -match '\d') {
        $pascalCaseName = "Icon" + $pascalCaseName # Prefix with "Icon" or similar
    }
    
    # If empty after processing (e.g. just "-"), provide a default
    if ([string]::IsNullOrWhiteSpace($pascalCaseName)) {
        $pascalCaseName = "UnknownIcon"
    }

    if ($csharpKeywords -contains $pascalCaseName.ToLower()) {
        $pascalCaseName = "@" + $pascalCaseName
    }
    
    return $pascalCaseName
}

function Get-IconNames {
    param (
        [string]$IconFolderPath
    )
    $iconNames = New-Object System.Collections.Generic.List[string]
    if (Test-Path $IconFolderPath) {
        Get-ChildItem -Path $IconFolderPath -Filter "*.svg" | ForEach-Object {
            $iconNames.Add($_.BaseName) # BaseName is filename without extension
        }
    } else {
        Write-Warning "Icon folder not found: $IconFolderPath"
    }
    return $iconNames | Sort-Object -Unique
}

# --- Main Script Logic ---

Write-Host "Starting Tabler Icon Name Generation..."
Write-Host "Tabler Icons Repository Path: $TablerRepoPath"
Write-Host "Output Namespace: $OutputNamespace"
Write-Host "Output File Path: $OutputFilePath"

$filledIconsPath = Join-Path -Path $TablerRepoPath -ChildPath "icons/filled"
$outlineIconsPath = Join-Path -Path $TablerRepoPath -ChildPath "icons/outline"

if (-not (Test-Path $filledIconsPath)) {
    Write-Error "Filled icons path does not exist: $filledIconsPath"
    exit 1
}
if (-not (Test-Path $outlineIconsPath)) {
    Write-Error "Outline icons path does not exist: $outlineIconsPath"
    exit 1
}

$filledIconRawNames = Get-IconNames -IconFolderPath $filledIconsPath
$outlineIconRawNames = Get-IconNames -IconFolderPath $outlineIconsPath

# Prepare C# code
$csharpFileContent = @"
// Generated by Generate-TablerIconNames.ps1
// DO NOT EDIT MANUALLY - REGENERATE INSTEAD

namespace $OutputNamespace
{
    /// <summary>
    /// Represents the names of Tabler Filled Icons.
    /// Use with the TablerIcon component.
    /// </summary>
    public enum TablerIconFilledName
    {
        /// <summary>
        /// Represents no specific icon, or a default/placeholder.
        /// </summary>
        None = 0, // Default value for enum
"@

$filledIconCount = 0
foreach ($rawName in $filledIconRawNames) {
    $enumMemberName = ConvertTo-PascalCaseIdentifier -Name $rawName
    $csharpFileContent += "`n        /// <summary>Icon: $rawName</summary>"
    $csharpFileContent += "`n        $enumMemberName,"
    $filledIconCount++
}

$csharpFileContent += @"

    }

    /// <summary>
    /// Represents the names of Tabler Outline Icons.
    /// Use with the TablerIcon component.
    /// </summary>
    public enum TablerIconOutlineName
    {
        /// <summary>
        /// Represents no specific icon, or a default/placeholder.
        /// </summary>
        None = 0, // Default value for enum
"@

$outlineIconCount = 0
foreach ($rawName in $outlineIconRawNames) {
    $enumMemberName = ConvertTo-PascalCaseIdentifier -Name $rawName
    $csharpFileContent += "`n        /// <summary>Icon: $rawName</summary>"
    $csharpFileContent += "`n        $enumMemberName,"
    $outlineIconCount++
}

$csharpFileContent += @"

    }

    // Helper class to convert enum names back to CSS-friendly kebab-case names
    internal static class TablerIconEnumConverter
    {
        public static string ToKebabCase(this TablerIconFilledName iconName)
        {
            if (iconName == TablerIconFilledName.None) return string.Empty;
            return ConvertEnumNameToKebabCase(iconName.ToString());
        }

        public static string ToKebabCase(this TablerIconOutlineName iconName)
        {
            if (iconName == TablerIconOutlineName.None) return string.Empty;
            return ConvertEnumNameToKebabCase(iconName.ToString());
        }

        private static string ConvertEnumNameToKebabCase(string enumString)
        {
            if (string.IsNullOrEmpty(enumString)) return string.Empty;

            // Remove "@" prefix if it was added for keywords
            if (enumString.StartsWith("@"))
            {
                enumString = enumString.Substring(1);
            }
            
            // Remove "Icon" prefix if it was added for names starting with a digit
            if (enumString.StartsWith("Icon") && enumString.Length > 4 && char.IsUpper(enumString[4]))
            {
                 // Check if the original started with a number by trying to parse the remainder
                 // This is a heuristic. A more robust way would be to store original name mapping.
                 // For now, we assume "Icon" prefix was for numbers or just a general prefix.
                 // A simpler approach is to always remove it if the next char is Upper,
                 // or rely on the PascalCase to kebab-case conversion to handle it.
                 // Let's try a general PascalCase to kebab-case conversion first.
            }
            // else if (enumString.StartsWith("Icon") && enumString.Length > 4 && char.IsDigit(enumString[4]))
            // {
            //    enumString = enumString.Substring(4); // Keep the number
            // }


            var builder = new System.Text.StringBuilder();
            for (int i = 0; i < enumString.Length; i++)
            {
                char currentChar = enumString[i];
                if (char.IsUpper(currentChar))
                {
                    if (i > 0 && (!char.IsUpper(enumString[i-1]) || (i + 1 < enumString.Length && char.IsLower(enumString[i+1]) && char.IsUpper(enumString[i-1])) ) )
                    {
                        builder.Append('-');
                    }
                    builder.Append(char.ToLower(currentChar));
                }
                else
                {
                    builder.Append(currentChar);
                }
            }
            var result = builder.ToString();
            // If the original started with "Icon" due to a leading number, the "Icon" part would become "icon-"
            // We need to strip "icon-" if the part after it was the original name.
            // Example: Icon123 -> icon-123. We want 123.
            // This part is tricky without knowing the exact original.
            // The `ConvertTo-PascalCaseIdentifier` prefixes with `Icon` for numbers.
            // So, if `result` starts with `icon-` and the next char is a digit, strip `icon-`.
            if (result.StartsWith("icon-") && result.Length > 5 && char.IsDigit(result[5]))
            {
                result = result.Substring(5);
            }
            return result;
        }
    }
}
"@

# Write to file
try {
    # Ensure the directory exists
    $outputDir = Split-Path -Path $OutputFilePath -Parent
    if ($outputDir -and (-not (Test-Path $outputDir))) {
        New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
    }
    
    Set-Content -Path $OutputFilePath -Value $csharpFileContent -Encoding UTF8
    Write-Host "Successfully generated C# enums to $OutputFilePath"
    Write-Host "Found $filledIconCount filled icons."
    Write-Host "Found $outlineIconCount outline icons."
}
catch {
    Write-Error "Failed to write C# file: $($_.Exception.Message)"
    exit 1
}

Write-Host "Script finished."